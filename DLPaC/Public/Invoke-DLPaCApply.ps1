function Invoke-DLPaCApply {
    <#
    .SYNOPSIS
        Applies the planned changes to DLP policies in the Microsoft 365 tenant.
    
    .DESCRIPTION
        The Invoke-DLPaCApply function executes the changes specified in a plan file generated by
        Get-DLPaCPlan. It creates, updates, or deletes DLP policies and rules in the Microsoft 365
        tenant according to the plan.
    
    .PARAMETER PlanPath
        The path to the plan file to apply. If not specified, the most recent plan file in the
        .dlpac/plans directory is used.
    
    .PARAMETER AutoApprove
        If specified, applies the changes without prompting for confirmation.
    
    .PARAMETER WhatIf
        If specified, shows what changes would be made without actually making them.
    
    .EXAMPLE
        Invoke-DLPaCApply
        
        Applies the most recent plan file after prompting for confirmation.
    
    .EXAMPLE
        Invoke-DLPaCApply -PlanPath "C:\DLP\.dlpac\plans\plan-20250415-123456.json" -AutoApprove
        
        Applies the specified plan file without prompting for confirmation.
    
    .NOTES
        This function requires an initialized DLPaC workspace and appropriate permissions to
        modify DLP policies in the Microsoft 365 tenant.
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    param (
        [Parameter(Position = 0)]
        [string]$PlanPath,
        
        [Parameter()]
        [switch]$AutoApprove
    )
    
    begin {
        # Helper function to convert PSCustomObject to hashtable recursively
        function ConvertTo-Hashtable {
            param (
                [Parameter(ValueFromPipeline)]
                $InputObject
            )
            
            process {
                if ($null -eq $InputObject) {
                    return $null
                }
                
                if ($InputObject -is [System.Management.Automation.PSCustomObject]) {
                    $hash = @{}
                    foreach ($property in $InputObject.PSObject.Properties) {
                        $hash[$property.Name] = ConvertTo-Hashtable -InputObject $property.Value
                    }
                    return $hash
                }
                elseif ($InputObject -is [System.Collections.IEnumerable] -and $InputObject -isnot [string]) {
                    $array = @()
                    foreach ($object in $InputObject) {
                        $array += ConvertTo-Hashtable -InputObject $object
                    }
                    return $array
                }
                else {
                    return $InputObject
                }
            }
        }
        # Initialize logger
        if (-not $script:Logger) {
            $script:Logger = [DLPaCLogger]::new()
        }
        
        $script:Logger.LogInfo("Starting plan application")
        
        # Validate workspace is initialized
        if (-not $script:WorkspacePath) {
            $errorMessage = "DLPaC workspace not initialized. Run Initialize-DLPaCWorkspace first."
            $script:Logger.LogError($errorMessage)
            throw $errorMessage
        }
        
        # Find most recent plan if not specified
        if (-not $PlanPath) {
            $plansDir = Join-Path $script:WorkspacePath ".dlpac\plans"
            
            if (-not (Test-Path $plansDir)) {
                $errorMessage = "Plans directory not found: $plansDir"
                $script:Logger.LogError($errorMessage)
                throw $errorMessage
            }
            
            # Find the most recent planning attempt (success or failure) by checking all plan and status files
            $allPlanFiles = Get-ChildItem -Path $plansDir -Filter "plan-*.json" -ErrorAction SilentlyContinue
            $allStatusFiles = Get-ChildItem -Path $plansDir -Filter "plan-*.status.json" -ErrorAction SilentlyContinue
            
            if ($allPlanFiles.Count -eq 0 -and $allStatusFiles.Count -eq 0) {
                $errorMessage = "No plan files found in $plansDir. Run Get-DLPaCPlan first."
                $script:Logger.LogError($errorMessage)
                throw $errorMessage
            }
            
            # Get the most recent planning attempt by timestamp (from filename)
            $mostRecentTimestamp = $null
            $mostRecentPlanPath = $null
            $mostRecentStatusPath = $null
            
            # Check all status files to find the most recent planning attempt
            foreach ($statusFile in $allStatusFiles) {
                if ($statusFile.Name -match 'plan-(\d{8}-\d{6})\.status\.json') {
                    $timestamp = $matches[1]
                    if (-not $mostRecentTimestamp -or $timestamp -gt $mostRecentTimestamp) {
                        $mostRecentTimestamp = $timestamp
                        $mostRecentStatusPath = $statusFile.FullName
                        $mostRecentPlanPath = $statusFile.FullName -replace '\.status\.json$', '.json'
                    }
                }
            }
            
            if (-not $mostRecentStatusPath) {
                $errorMessage = "No valid status files found in $plansDir. This indicates an incomplete planning process."
                $script:Logger.LogError($errorMessage)
                throw $errorMessage
            }
            
            # Read and validate the status of the most recent planning attempt
            try {
                $mostRecentStatus = Get-Content -Path $mostRecentStatusPath -Raw | ConvertFrom-Json
                if ($mostRecentStatus.status -ne "success") {
                    $reason = if ($mostRecentStatus.reason) { " Reason: $($mostRecentStatus.reason)" } else { "" }
                    $errorCount = if ($mostRecentStatus.errorCount) { " ($($mostRecentStatus.errorCount) errors)" } else { "" }
                    $errorMessage = "Cannot apply: Most recent planning attempt failed with status '$($mostRecentStatus.status)'$reason$errorCount. Fix configuration issues and run Get-DLPaCPlan again."
                    $script:Logger.LogError($errorMessage)
                    throw $errorMessage
                }
                
                # Verify that the corresponding plan file exists
                if (-not (Test-Path $mostRecentPlanPath)) {
                    $errorMessage = "Plan file not found: $mostRecentPlanPath. This indicates an incomplete planning process."
                    $script:Logger.LogError($errorMessage)
                    throw $errorMessage
                }
                
                $PlanPath = $mostRecentPlanPath
                $script:Logger.LogInfo("Most recent planning was successful - proceeding with apply")
                $script:Logger.LogInfo("Using most recent plan file: $PlanPath")
            }
            catch {
                if ($_.Exception.Message -like "*Cannot apply*" -or $_.Exception.Message -like "*Plan file not found*") {
                    throw $_
                }
                $errorMessage = "Failed to read or parse most recent plan status file: $mostRecentStatusPath. Error: $_"
                $script:Logger.LogError($errorMessage)
                throw $errorMessage
            }
        }
        
        # Validate plan file exists
        if (-not (Test-Path $PlanPath)) {
            $errorMessage = "Plan file not found: $PlanPath"
            $script:Logger.LogError($errorMessage)
            throw $errorMessage
        }
        
        # Validate plan status
        $statusPath = $PlanPath -replace '\.json$', '.status.json'
        if (-not (Test-Path $statusPath)) {
            $errorMessage = "Plan status file not found: $statusPath. This indicates the plan may be from an older version or incomplete planning process."
            $script:Logger.LogError($errorMessage)
            throw $errorMessage
        }
        
        try {
            $planStatus = Get-Content -Path $statusPath -Raw | ConvertFrom-Json
            if ($planStatus.status -ne "success") {
                $reason = if ($planStatus.reason) { " Reason: $($planStatus.reason)" } else { "" }
                $errorMessage = "Cannot apply plan - last planning attempt failed with status: $($planStatus.status).$reason Run Get-DLPaCPlan again to generate a valid plan."
                $script:Logger.LogError($errorMessage)
                throw $errorMessage
            }
            $script:Logger.LogInfo("Plan status validated: $($planStatus.status) at $($planStatus.timestamp)")
        }
        catch {
            if ($_.Exception.Message -like "*Cannot apply plan*") {
                throw $_
            }
            $errorMessage = "Failed to read or parse plan status file: $statusPath. Error: $_"
            $script:Logger.LogError($errorMessage)
            throw $errorMessage
        }
        
        # Initialize IPPSP adapter (reuse cached adapter when manual session active)
        if ($script:IPPSPAdapter) {
            $ippspAdapter = $script:IPPSPAdapter
        }
        else {
            $ippspAdapter = [DLPaCIPPSPAdapter]::new($script:Logger)
        }
    }
    
    process {
        try {
            # Ensure online connectivity
            if (-not $ippspAdapter.IsConnected) {
                $script:Logger.LogInfo("Connecting to Exchange Online")
                $connected = $ippspAdapter.Connect()
                
                if (-not $connected) {
                    $errorMessage = "Online connectivity required for apply operations. Failed to connect to Exchange Online."
                    $script:Logger.LogError($errorMessage)
                    throw $errorMessage
                }
            }
            
            # Load plan
            $script:Logger.LogInfo("Loading plan from $PlanPath")
            $plan = [DLPaCPlan]::Load($PlanPath)
            
            # Display plan summary
            $summary = $plan.GenerateSummary()
            Write-Host $summary
            
            # Check if there are any changes
            if (-not $plan.HasChanges()) {
                $script:Logger.LogInfo("No changes to apply")
                Write-Host "No changes to apply. Your infrastructure matches the configuration."
                return
            }
            
            # Confirm application
            if (-not $AutoApprove -and -not $WhatIfPreference) {
                $confirmation = Read-Host "Do you want to apply these changes? (y/n)"
                
                if ($confirmation -ne "y") {
                    $script:Logger.LogInfo("Plan application cancelled by user")
                    Write-Host "Plan application cancelled."
                    return
                }
            }
            
            # Connection already ensured earlier; skipping redundant connect
            
            # Load state
            $statePath = $script:StatePath
            if (-not $statePath) {
                $statePath = Join-Path $script:WorkspacePath ".dlpac\state\dlpac.state.json"
            }
            
            $script:Logger.LogInfo("Loading state from $statePath")
            $state = [DLPaCState]::Load($statePath)
            
            # Lock state file
            $script:Logger.LogInfo("Locking state file")
            $state.Lock()
            
            # Apply changes
            $changeCount = $plan.GetChangeCount()
            $currentChange = 0
            $successCount = 0
            $failureCount = 0
            
            foreach ($change in $plan.Changes) {
                $currentChange++
                $progressPercent = [math]::Round(($currentChange / $changeCount) * 100)
                
                Write-Progress -Activity "Applying changes" -Status "$currentChange of $changeCount" -PercentComplete $progressPercent
                
                $script:Logger.LogInfo("Processing change: $change")
                
                try {
                    if ($PSCmdlet.ShouldProcess($change.ResourceName, "$($change.Operation) $($change.ResourceType)")) {
                        switch ($change.ResourceType) {
                            "Policy" {
                                switch ($change.Operation) {
                                    "Create" {
                                        $policy = [DLPaCPolicy]::new($change.ResourceName)
                                        $policy.Description = $change.NewState.Description
                                        $policy.Mode = $change.NewState.Mode
                                        $policy.Priority = $change.NewState.Priority
                                        $policy.Scope = ConvertTo-Hashtable -InputObject $change.NewState.Scope
                                        
                                        # Add rules
                                        foreach ($ruleState in $change.NewState.Rules) {
                                            $rule = [DLPaCRule]::new($ruleState.Name)
                                            $rule.PolicyName = $policy.Name
                                            
                                            # Add conditions
                                            foreach ($conditionState in $ruleState.Conditions) {
                                                $condition = [DLPaCCondition]::new($conditionState.Type)
                                                
                                                if ($conditionState.Pattern) {
                                                    $condition.Pattern = $conditionState.Pattern
                                                }
                                                
                                                if ($conditionState.InfoType) {
                                                    $condition.InfoType = $conditionState.InfoType
                                                }
                                                
                                                if ($conditionState.MinCount) {
                                                    $condition.MinCount = $conditionState.MinCount
                                                }
                                                
                                                if ($conditionState.Operator) {
                                                    $condition.Operator = $conditionState.Operator
                                                }
                                                
                                                if ($conditionState.Value) {
                                                    $condition.Value = $conditionState.Value
                                                }
                                                
                                                $rule.AddCondition($condition)
                                            }
                                            
                                            # Add actions
                                            foreach ($actionState in $ruleState.Actions) {
                                                $action = [DLPaCAction]::new($actionState.Type)
                                                
                                                if ($null -ne $actionState.NotifyUser) {
                                                    $action.NotifyUser = $actionState.NotifyUser
                                                }
                                                
                                                if ($null -ne $actionState.NotifyAdmin) {
                                                    $action.NotifyAdmin = $actionState.NotifyAdmin
                                                }
                                                
                                                if ($actionState.EncryptionMethod) {
                                                    $action.EncryptionMethod = $actionState.EncryptionMethod
                                                }
                                                
                                                $rule.AddAction($action)
                                            }
                                            
                                            $policy.AddRule($rule)
                                        }
                                        
                                        $script:Logger.LogInfo("Creating policy $($policy.Name) with configuration hash $($policy.GenerateConfigHash())")
                                        $result = $ippspAdapter.CreatePolicy($policy)
                                        
                                        # Update state and cache with applied state
                                        $state.AddPolicy($policy)
                                        $state.UpdateTenantCache($policy.Name, @{
                                            Id = $result.Id
                                            LastModified = $result.LastModified
                                            Hash = $policy.GenerateHash()
                                        })
                                        
                                        $successCount++
                                    }
                                    "Update" {
                                        $policy = [DLPaCPolicy]::new($change.ResourceName)
                                        $policy.Id = $state.GetPolicyId($change.ResourceName)
                                        $policy.Description = $change.NewState.Description
                                        $policy.Mode = $change.NewState.Mode
                                        $policy.Priority = $change.NewState.Priority
                                        $policy.Scope = ConvertTo-Hashtable -InputObject $change.NewState.Scope
                                        
                                        # Add rules
                                        foreach ($ruleState in $change.NewState.Rules) {
                                            $rule = [DLPaCRule]::new($ruleState.Name)
                                            $rule.PolicyName = $policy.Name
                                            $rule.Id = $state.GetRuleId($policy.Name, $rule.Name)
                                            
                                            # Add conditions
                                            foreach ($conditionState in $ruleState.Conditions) {
                                                $condition = [DLPaCCondition]::new($conditionState.Type)
                                                
                                                if ($conditionState.Pattern) {
                                                    $condition.Pattern = $conditionState.Pattern
                                                }
                                                
                                                if ($conditionState.InfoType) {
                                                    $condition.InfoType = $conditionState.InfoType
                                                }
                                                
                                                if ($conditionState.MinCount) {
                                                    $condition.MinCount = $conditionState.MinCount
                                                }
                                                
                                                if ($conditionState.Operator) {
                                                    $condition.Operator = $conditionState.Operator
                                                }
                                                
                                                if ($conditionState.Value) {
                                                    $condition.Value = $conditionState.Value
                                                }
                                                
                                                $rule.AddCondition($condition)
                                            }
                                            
                                            # Add actions
                                            foreach ($actionState in $ruleState.Actions) {
                                                $action = [DLPaCAction]::new($actionState.Type)
                                                
                                                if ($null -ne $actionState.NotifyUser) {
                                                    $action.NotifyUser = $actionState.NotifyUser
                                                }
                                                
                                                if ($null -ne $actionState.NotifyAdmin) {
                                                    $action.NotifyAdmin = $actionState.NotifyAdmin
                                                }
                                                
                                                if ($actionState.EncryptionMethod) {
                                                    $action.EncryptionMethod = $actionState.EncryptionMethod
                                                }
                                                
                                                $rule.AddAction($action)
                                            }
                                            
                                            $policy.AddRule($rule)
                                        }
                                        
                                        $script:Logger.LogInfo("Updating policy $($policy.Name) with new configuration hash $($policy.GenerateConfigHash())")
                                        $result = $ippspAdapter.UpdatePolicy($policy)
                                        
                                        # Update state and cache with new applied state
                                        $state.AddPolicy($policy)
                                        $state.UpdateTenantCache($policy.Name, @{
                                            Id = $result.Id
                                            LastModified = $result.LastModified
                                            Hash = $policy.GenerateHash()
                                        })
                                        
                                        $successCount++
                                    }
                                    "Delete" {
                                        $script:Logger.LogInfo("Deleting policy $($change.ResourceName)")
                                        $ippspAdapter.DeletePolicy($change.ResourceName)
                                        
                                        # Clean up state and cache
                                        $state.RemovePolicy($change.ResourceName)
                                        $state.InvalidateCache($change.ResourceName)
                                        
                                        $successCount++
                                    }
                                }
                            }
                            "Rule" {
                                # Rules are handled as part of policy operations
                                $successCount++
                            }
                        }
                    }
                }
                catch {
                    $script:Logger.LogError("Failed to apply change: $change. Error: $_")
                    $failureCount++
                }
            }
            
            Write-Progress -Activity "Applying changes" -Completed
            
            # Save state
            $script:Logger.LogInfo("Saving state")
            $state.Save()
            
            # Unlock state file
            $script:Logger.LogInfo("Unlocking state file")
            $state.Unlock()
            
            # Display results
            $script:Logger.LogInfo("Plan application completed. Success: $successCount, Failure: $failureCount")
            
            [PSCustomObject]@{
                PlanPath = $PlanPath
                TotalChanges = $changeCount
                SuccessCount = $successCount
                FailureCount = $failureCount
                CompletedAt = Get-Date
            }
        }
        catch {
            $script:Logger.LogError("Error applying plan: $_")
            throw $_
        }
        finally {
            # Unlock state file if locked
            if ($state -and $state.IsLocked) {
                $script:Logger.LogInfo("Unlocking state file")
                $state.Unlock()
            }
            
            # Disconnect from Exchange Online only when not in a manual session
            if (-not $script:ManualSessionActive -and $ippspAdapter.IsConnected) {
                $script:Logger.LogInfo("Disconnecting from Exchange Online")
                $ippspAdapter.Disconnect()
            }
        }
    }
}